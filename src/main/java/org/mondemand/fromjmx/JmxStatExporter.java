package org.mondemand.fromjmx;

import java.io.IOException;
import java.lang.management.ManagementFactory;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Map.Entry;

import javax.management.Attribute;
import javax.management.AttributeList;
import javax.management.JMException;
import javax.management.MBeanAttributeInfo;
import javax.management.MBeanInfo;
import javax.management.MBeanServerConnection;
import javax.management.ObjectName;
import javax.management.openmbean.CompositeData;
import javax.management.openmbean.CompositeType;
import javax.management.remote.JMXConnector;
import javax.management.remote.JMXConnectorFactory;
import javax.management.remote.JMXServiceURL;

/**
 * Exports JMX statistics from a JVM to mondemand.
 *  
 * @author Joel Meyer (joel.meyer@openx.org)
 */
public class JmxStatExporter {
  protected static final String SEPARATOR = ".";

  protected static class Attributes {
    public final Map<String,String> exportValueAs = new HashMap<String,String>();
    public final Map<String,Attributes> exportSubValueAs = new HashMap<String,Attributes>();
    public String[] asArray;
  }

  protected final List<ExportedBean> exportedBeans;
  protected final Map<ObjectName, Attributes> oNameAttrsMap;
  protected final MBeanServerConnection beanServer;

  /**
   * Constructor. Connects to the local JVM and gets all exportable attributes.
   * @throws IOException
   */
  public JmxStatExporter() throws IOException {
    this.beanServer = ManagementFactory.getPlatformMBeanServer();
    this.oNameAttrsMap = queryAttrs();
    this.exportedBeans = toExportedBeanList(oNameAttrsMap);
  }

  /**
   * Constructor. Connects to the local JVM and attempts to get the
   * specified exportable properties.
   * @param exportedBeans The beans/properties to export.
   * @throws IOException If there is a problem getting any of the
   *                     specified beans/properties.
   */
  public JmxStatExporter(List<ExportedBean> exportedBeans) throws IOException {
    this.beanServer = ManagementFactory.getPlatformMBeanServer();
    this.oNameAttrsMap = toMap(exportedBeans);
    this.exportedBeans = exportedBeans;
  }

  /**
   * Constructor. Connects to the JVM at the given host and port.
   * Gets all exportable attributes.
   * @param host Host the JVM is running on.
   * @param port Port the JVM is listening for JMX connections on.
   * @throws IOException If there is a problem connecting to the JVM.
   */
  public JmxStatExporter(String host, int port) throws IOException {
    JMXServiceURL jmxURL = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://" + host + ":" + port + "/jmxrmi");
    JMXConnector jmxConnector = JMXConnectorFactory.connect(jmxURL);
    this.beanServer = jmxConnector.getMBeanServerConnection();
    this.oNameAttrsMap = queryAttrs();
    this.exportedBeans = toExportedBeanList(oNameAttrsMap);
  }

  /**
   * Constructor. Connects to the JVM at the given host and port.
   * Attempts to get the specified exportable properties.
   * @param host Host the JVM is running on.
   * @param port Port the JVM is listening for JMX connections on.
   * @param exportedBeans The beans/properties to export.
   * @throws IOException If there is a problem connecting to the JVM or
   *                     getting any of the specified beans/properties.
   */
  public JmxStatExporter(String host, int port, List<ExportedBean> exportedBeans) throws IOException {
    JMXServiceURL jmxURL = new JMXServiceURL("service:jmx:rmi:///jndi/rmi://" + host + ":" + port + "/jmxrmi");
    JMXConnector jmxConnector = JMXConnectorFactory.connect(jmxURL);
    this.beanServer = jmxConnector.getMBeanServerConnection();
    this.oNameAttrsMap = toMap(exportedBeans);
    this.exportedBeans = exportedBeans;
  }
  
  /**
   * If a list of {@link ExportedBean}'s was passed in, this method will
   * return that list. If no list was provided, this method will return
   * the list that was generated by inspecting the remote JVM.
   * @return The list representing the currently exported bean/attributes.
   */
  public List<ExportedBean> getExportedBeans() {
    return exportedBeans;
  }
  
  /**
   * Get all the exported stats.
   * @return
   */
  public List<ExportedStat> getExportedStats() {
    List<ExportedStat> exportedStats = new ArrayList<ExportedStat>(50);

    for (Entry<ObjectName,Attributes> oNameAttrs : oNameAttrsMap.entrySet()) {
      try {
        ObjectName oName = oNameAttrs.getKey();
        Attributes attrs = oNameAttrs.getValue();
        AttributeList attrList = beanServer.getAttributes(oName, attrs.asArray);
        addExportedStats(attrs, attrList, exportedStats);
      } catch (IOException e) {
        e.printStackTrace();
      } catch (JMException e) {
        e.printStackTrace();
      }
    }

    return exportedStats;
  }
  
  /**
   * Used to recurse through the attributes of a MBean and create {@link ExportedAttribute}
   * objects for the fields and add them to the {@link ExportedBean}.
   * @param prefix
   * @param attrs
   * @param exportedBean
   */
  protected void addExportedAttributes(String prefix, Attributes attrs, ExportedBean exportedBean) {
    // Add attributes at this level
    for (Entry<String,String> entry : attrs.exportValueAs.entrySet()) {
      String key = (prefix == null) ? entry.getKey() : prefix + SEPARATOR + entry.getKey();
      exportedBean.addExportedAttribute(new ExportedAttribute(key, entry.getValue()));
    }

    // Recurse over sub-attributes
    for (Entry<String,Attributes> entry : attrs.exportSubValueAs.entrySet()) {
      String key = (prefix == null) ? entry.getKey() : prefix + SEPARATOR + entry.getKey();
      addExportedAttributes(key, entry.getValue(), exportedBean);
    }
  }
  
  /**
   * Creates a list of {@link ExportedBean} objects from the internal representation,
   * which is a {@link Map<String,Attributes>}.
   * @param oNameAttrsMap
   * @return
   */
  protected List<ExportedBean> toExportedBeanList(Map<ObjectName,Attributes> oNameAttrsMap) {
    List<ExportedBean> exportedBeanList = new ArrayList<ExportedBean>(oNameAttrsMap.size());

    for (Entry<ObjectName,Attributes> entry : oNameAttrsMap.entrySet()) {
      ExportedBean exportedBean = new ExportedBean(entry.getKey().getCanonicalName());
      addExportedAttributes(null, entry.getValue(), exportedBean);
      exportedBeanList.add(exportedBean);
    }
    
    return exportedBeanList;
  }
  
  /**
   * Get all attribute names and stick them into the string array member of the
   * {@link Attributes} object so they can be quickly queried.
   * @param attrs
   */
  protected void initAttrNameArray(Attributes attrs) {
    int attrCnt = attrs.exportValueAs.size() + attrs.exportSubValueAs.size();
    if (attrCnt > 0) {
      attrs.asArray = new String[attrCnt];

      int i = 0;
      for (String attrName : attrs.exportValueAs.keySet()) {
        attrs.asArray[i++] = attrName;
      }
      for (String attrName : attrs.exportSubValueAs.keySet()) {
        attrs.asArray[i++] = attrName;
      }
    }
  }
  
  /**
   * Recursively calls {@link JmxStatExporter.initAttrNameArray} on an
   * {@link Attributes} object.
   * @param attrs
   */
  protected void deepInitAttrNameArray(Attributes attrs) {
    initAttrNameArray(attrs);
    for (Entry<String,Attributes> subAttrsEntry : attrs.exportSubValueAs.entrySet()) {
      deepInitAttrNameArray(subAttrsEntry.getValue());
    }
  }

  /**
   * Adds an attribute to the given {@link Attributes} object, recursing as necessary.
   * @param attrs
   * @param exportName
   * @param attrPath
   * @param pathIdx
   */
  protected void addExportedAttr(Attributes attrs, String exportName, String[] attrPath, int pathIdx) {
    if (pathIdx == attrPath.length - 1) {
      attrs.exportValueAs.put(attrPath[pathIdx], exportName);
    } else {
      Attributes subAttrs = attrs.exportSubValueAs.get(attrPath[pathIdx]);
      if (subAttrs == null) {
        subAttrs = new Attributes();
        attrs.exportSubValueAs.put(attrPath[pathIdx], subAttrs);
      }
      addExportedAttr(subAttrs, exportName, attrPath, pathIdx + 1);
    }
  }
  
  /**
   * Constructs the internally used {@link Map<ObjectName,Attributes>} object from
   * a list of {@link ExportedBean} objects.
   * @param exportedBeans
   * @return
   */
  protected Map<ObjectName,Attributes> toMap(List<ExportedBean> exportedBeans) {
    Map<ObjectName,Attributes> oNameAttrsMap = new HashMap<ObjectName,Attributes>();
    
    Set<ObjectName> oNames = null;
    
    for (ExportedBean exportedBean : exportedBeans) {
      try {
        oNames = beanServer.queryNames(new ObjectName(exportedBean.getObjectNameIdentifier()), null);
        
        for (ObjectName oName : oNames) {
          Attributes attrs = oNameAttrsMap.get(oName);
          if (attrs == null) {
            attrs = new Attributes();
            oNameAttrsMap.put(oName, attrs);
          }
          
          for (ExportedAttribute exportedAttribute : exportedBean.getExportedAttributes()) {
            addExportedAttr(attrs, exportedAttribute.exportName, exportedAttribute.name.split("\\."), 0);
          }
        }
        
      } catch (Exception e) {
        e.printStackTrace();
      }
    }
    
    // Create the arrays of attributes so fetching is easier
    for (Entry<ObjectName,Attributes> entry : oNameAttrsMap.entrySet()) {
      deepInitAttrNameArray(entry.getValue());
    }
    
    return oNameAttrsMap;
  }

  protected String getName(ObjectName oName) {
    String name = oName.getKeyProperty("name");
    return (name != null && !name.isEmpty()) ? name.replace(' ', '_') : null;
  }

  
  
  /**
   * Converts a {@link CompositeData} object to an {@link AttributeList}.
   * @param cd
   * @return
   */
  protected AttributeList toAttributeList(CompositeData cd) {
    CompositeType ct = cd.getCompositeType();

    // Get key set and convert to array
    Set<String> keySet = ct.keySet();
    String[] keyAry = new String[keySet.size()];
    keySet.toArray(keyAry);
    
    // Get array of values
    Object[] subVals = cd.getAll(keyAry);
    
    // Create AttributeList from keys and values
    AttributeList attrList = new AttributeList(subVals.length);
    for (int i = 0; i < subVals.length; i++) {
      attrList.add(new Attribute(keyAry[i], subVals[i]));
    }
    
    return attrList;
  }

  /**
   * Returns an {@link Attributes} containing all the exportable attributes from
   * the given {@link AttributeList}. If no attributes are exportable null
   * is returned.
   * @param prefix
   * @param attrList
   * @return
   */
  protected Attributes getAttrs(String prefix, AttributeList attrList) {
    Attributes attrs = new Attributes();
    Iterator<Object> attrValItr = attrList.iterator();
    while (attrValItr.hasNext()) {
      Attribute attr = ((Attribute)attrValItr.next());
      String name = attr.getName();
      Object val = attr.getValue();
      
      String exportName = (prefix == null) ? name : prefix + SEPARATOR + name;
      
      if (val instanceof Long) {
        attrs.exportValueAs.put(name, exportName);
      } else if (val instanceof Integer) {
        attrs.exportValueAs.put(name, exportName);
      } else if (val instanceof CompositeData) {
        // Recurse
        Attributes subAttrs = getAttrs(exportName, toAttributeList((CompositeData)val));
        if (subAttrs != null) {
          attrs.exportSubValueAs.put(name, subAttrs);
        }
      }
    }

    initAttrNameArray(attrs);

    return (attrs.asArray != null) ? attrs : null;
  }

  /**
   * Queries the {@link MBeanServer} and constructs a map containing all
   * exportable beans/attributes. 
   * @return
   * @throws IOException
   */
  protected Map<ObjectName,Attributes> queryAttrs() throws IOException {
    Set<ObjectName> oNames = beanServer.queryNames(null, null);

    Map<ObjectName,Attributes> oNameAttrsMap = new HashMap<ObjectName,Attributes>();
    for (ObjectName oName : oNames) {
      try {
        MBeanInfo beanInfo = beanServer.getMBeanInfo(oName);

        List<String> attrNameList = new ArrayList<String>();
        for (MBeanAttributeInfo attrInfo : beanInfo.getAttributes()) {
          attrNameList.add(attrInfo.getName());
        }

        String[] attrNameAry = new String[attrNameList.size()];
        attrNameList.toArray(attrNameAry);

        Attributes attrs = getAttrs(getName(oName), beanServer.getAttributes(oName, attrNameAry));

        if (attrs != null) {
          oNameAttrsMap.put(oName, attrs);
        }
      } catch (JMException e) {
        e.printStackTrace();
      }
    }

    return oNameAttrsMap;
  }

  /**
   * Recursively add attributes.
   * @param attrs
   * @param attrList
   * @param statAccumulator
   */
  protected void addExportedStats(Attributes attrs, AttributeList attrList, List<ExportedStat> statAccumulator) {
    Iterator<Object> attrItr = attrList.iterator();
    while (attrItr.hasNext()) {
      Attribute beanAttr = (Attribute)attrItr.next();
      String name = beanAttr.getName();
      Object value = beanAttr.getValue();

      if (value instanceof Long) {
        statAccumulator.add(new ExportedStat(attrs.exportValueAs.get(name), ((Long)value).longValue()));
      } else if (value instanceof Integer) {
        statAccumulator.add(new ExportedStat(attrs.exportValueAs.get(name), ((Integer)value).longValue()));
      } else if (value instanceof CompositeData) {
        AttributeList subAttrList = toAttributeList((CompositeData)value);
        addExportedStats(attrs.exportSubValueAs.get(name), subAttrList, statAccumulator);
      }
    }
  }
}
